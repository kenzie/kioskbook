#!/bin/bash
#
# KioskBook Management CLI
#
# Manage and monitor KioskBook kiosk installations
#

set -euo pipefail

# Configuration
readonly REPO_DIR="/opt/kioskbook-repo"
readonly APP_DIR="/opt/kioskbook"
readonly VERSION_FILE="/etc/kioskbook/version"
readonly KIOSKBOOK_SERVICE="kioskbook-app.service"
readonly DISPLAY_SERVICE="lightdm.service"

# Colors (using $'...' syntax for proper escape sequence interpretation)
readonly RED=$'\033[0;31m'
readonly GREEN=$'\033[0;32m'
readonly YELLOW=$'\033[1;33m'
readonly CYAN=$'\033[0;36m'
readonly BLUE=$'\033[1;36m'  # Bright cyan for better visibility on black background
readonly NC=$'\033[0m'

# Logging functions
log() { printf "${CYAN}[KIOSK]${NC} %s\n" "$1"; }
log_success() { printf "${GREEN}[SUCCESS]${NC} %s\n" "$1"; }
log_warning() { printf "${YELLOW}[WARNING]${NC} %s\n" "$1"; }
log_error() { printf "${RED}[ERROR]${NC} %s\n" "$1" >&2; exit 1; }

# Check if running as root
require_root() {
    if [[ $EUID -ne 0 ]]; then
        log_error "This command must be run as root (use sudo)"
    fi
}

# Get installed version
get_installed_version() {
    if [[ -f "$VERSION_FILE" ]]; then
        cat "$VERSION_FILE"
    else
        echo "unknown"
    fi
}

# Get repository version
get_repo_version() {
    if [[ -f "$REPO_DIR/VERSION" ]]; then
        cat "$REPO_DIR/VERSION"
    else
        echo "unknown"
    fi
}

# Command: version
cmd_version() {
    local installed=$(get_installed_version)
    local repo=$(get_repo_version)

    echo -e "${CYAN}KioskBook Version Information${NC}"
    echo -e "Installed version: ${GREEN}$installed${NC}"

    if [[ -d "$REPO_DIR" ]]; then
        echo -e "Repository version: ${GREEN}$repo${NC}"

        if [[ "$installed" != "$repo" ]]; then
            echo -e "${YELLOW}⚠️  Update available!${NC} Run: ${YELLOW}kiosk update all${NC}"
        fi
    fi
}

# Command: status
cmd_status() {
    echo -e "${CYAN}KioskBook System Status${NC}\n"

    # Application service
    echo -n "Application Service: "
    if systemctl is-active --quiet "$KIOSKBOOK_SERVICE"; then
        echo -e "${GREEN}✅ Running${NC}"
    else
        echo -e "${RED}❌ Stopped${NC}"
    fi

    # Display service
    echo -n "Display Service: "
    if systemctl is-active --quiet "$DISPLAY_SERVICE"; then
        echo -e "${GREEN}✅ Running${NC}"
    else
        echo -e "${RED}❌ Stopped${NC}"
    fi

    # Chromium kiosk
    echo -n "Chromium Kiosk: "
    if pgrep -f "chromium.*kiosk" >/dev/null; then
        echo -e "${GREEN}✅ Running${NC}"
    else
        echo -e "${RED}❌ Not running${NC}"
    fi

    # Network
    echo -n "Network: "
    if ping -c 1 -W 2 google.com >/dev/null 2>&1; then
        echo -e "${GREEN}✅ Connected${NC}"
    else
        echo -e "${YELLOW}⚠️  Offline${NC}"
    fi

    # Tailscale
    echo -n "Tailscale VPN: "
    if command -v tailscale >/dev/null 2>&1; then
        if tailscale status >/dev/null 2>&1; then
            echo -e "${GREEN}✅ Connected${NC}"
        else
            echo -e "${YELLOW}⚠️  Not connected${NC}"
        fi
    else
        echo -e "${BLUE}Not installed${NC}"
    fi

    # Uptime
    echo -e "\nSystem Uptime: $(uptime -p)"
    echo -e "Load Average: $(uptime | awk -F'load average:' '{print $2}')"

    # Memory
    echo -e "Memory Usage: $(free -m | awk '/^Mem:/ {printf "%dMB/%dMB (%d%%)", $3, $2, ($3/$2*100)}')"

    # Application port check
    echo -n "Application Port (5173): "
    if curl -s --max-time 2 http://localhost:5173 >/dev/null 2>&1; then
        echo -e "${GREEN}✅ Responding${NC}"
    else
        echo -e "${RED}❌ Not responding${NC}"
    fi
}

# Command: health
cmd_health() {
    local detailed=false
    if [[ "${1:-}" == "--detailed" ]] || [[ "${1:-}" == "-d" ]]; then
        detailed=true
    fi

    if [[ -x /usr/local/bin/kioskbook-health ]]; then
        /usr/local/bin/kioskbook-health
    else
        log_warning "Health check script not installed"
        cmd_status
    fi

    if [[ "$detailed" == true ]]; then
        echo -e "\n${CYAN}Detailed System Information${NC}"
        echo -e "Kernel: $(uname -r)"
        echo -e "OS: $(cat /etc/os-release | grep PRETTY_NAME | cut -d'"' -f2)"
        echo -e "Node.js: $(node --version 2>/dev/null || echo 'Not installed')"
        echo -e "npm: $(npm --version 2>/dev/null || echo 'Not installed')"

        echo -e "\n${CYAN}Disk Usage${NC}"
        df -h / | tail -1 | awk '{print "Root: "$3"/"$2" ("$5" used)"}'

        echo -e "\n${CYAN}Service Status${NC}"
        systemctl status "$KIOSKBOOK_SERVICE" --no-pager -l | head -10
    fi
}

# Command: logs
cmd_logs() {
    local follow=false
    local lines=50

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -f|--follow)
                follow=true
                shift
                ;;
            -n|--lines)
                lines="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ "$follow" == true ]]; then
        journalctl -u "$KIOSKBOOK_SERVICE" -f
    else
        journalctl -u "$KIOSKBOOK_SERVICE" -n "$lines" --no-pager
    fi
}

# Command: modules
cmd_modules() {
    if [[ ! -d "$REPO_DIR/modules" ]]; then
        log_error "Repository not found at $REPO_DIR. Run migration first."
    fi

    echo -e "${CYAN}Available Modules${NC}\n"

    for module in $(find "$REPO_DIR/modules" -name "[0-9][0-9]-*.sh" | sort); do
        local name=$(basename "$module")
        local description=$(grep "^# Description:" "$module" | sed 's/^# Description: //')
        printf "  ${GREEN}%-20s${NC} %s\n" "$name" "$description"
    done

    echo -e "\n${CYAN}Usage${NC}"
    echo "  Update single module: kiosk update <module-name>"
    echo "  Update all modules:   kiosk update all"
    echo ""
    echo "Examples:"
    echo "  kiosk update 30-display"
    echo "  kiosk update 70-services"
}

# Command: update
cmd_update() {
    require_root

    if [[ ! -d "$REPO_DIR" ]]; then
        log_error "Repository not found at $REPO_DIR. Run migration first."
    fi

    local module_name="${1:-}"

    if [[ -z "$module_name" ]]; then
        log_error "Usage: kiosk update <module-name|all>"
    fi

    # Pull latest from repo
    log "Pulling latest changes from repository..."
    cd "$REPO_DIR"
    git pull

    # Update kiosk CLI first (before loading common.sh)
    if [[ "$module_name" == "all" ]]; then
        log "Updating kiosk CLI..."
        cp "$REPO_DIR/bin/kiosk" /usr/local/bin/kiosk.new
        chmod +x /usr/local/bin/kiosk.new
        mv /usr/local/bin/kiosk.new /usr/local/bin/kiosk
        log_success "kiosk CLI updated"
    fi

    # Load common functions
    source "$REPO_DIR/lib/common.sh"

    if [[ "$module_name" == "all" ]]; then
        log "Updating all modules..."

        # Run pending migrations first
        log "Checking for pending migrations..."
        run_pending_migrations "$REPO_DIR/migrations"

        # Then run all modules
        for module in $(find "$REPO_DIR/modules" -name "[0-9][0-9]-*.sh" | sort); do
            log "Running module: $(basename "$module")"
            bash "$module"
        done

        # Update installed version
        if [[ -f "$REPO_DIR/VERSION" ]]; then
            mkdir -p "$(dirname "$VERSION_FILE")"
            cp "$REPO_DIR/VERSION" "$VERSION_FILE"
            log_success "Updated to version $(cat "$VERSION_FILE")"
        fi
    else
        # Update single module
        local module_path=""

        # Try exact match with .sh extension
        if [[ -f "$REPO_DIR/modules/${module_name}.sh" ]]; then
            module_path="$REPO_DIR/modules/${module_name}.sh"
        # Try exact match without extension
        elif [[ -f "$REPO_DIR/modules/$module_name" ]]; then
            module_path="$REPO_DIR/modules/$module_name"
        # Try matching with number prefix (e.g., "app" matches "50-app.sh")
        else
            local matches=($(find "$REPO_DIR/modules" -name "[0-9][0-9]-${module_name}.sh" 2>/dev/null))
            if [[ ${#matches[@]} -eq 1 ]]; then
                module_path="${matches[0]}"
            elif [[ ${#matches[@]} -gt 1 ]]; then
                log_error "Multiple modules match '$module_name': ${matches[*]}"
            else
                log_error "Module not found: $module_name"
            fi
        fi

        log "Running module: $(basename "$module_path")"
        bash "$module_path"
    fi

    log_success "Update complete"
}

# Command: restart
cmd_restart() {
    require_root

    local service="${1:-all}"

    case "$service" in
        app|application)
            log "Restarting application service..."
            systemctl restart "$KIOSKBOOK_SERVICE"
            log_success "Application restarted"
            ;;
        display)
            log "Restarting display service..."
            systemctl restart "$DISPLAY_SERVICE"
            log_success "Display restarted"
            ;;
        all)
            log "Restarting all services..."
            systemctl restart "$KIOSKBOOK_SERVICE"
            systemctl restart "$DISPLAY_SERVICE"
            log_success "All services restarted"
            ;;
        *)
            log_error "Usage: kiosk restart [app|display|all]"
            ;;
    esac
}

# Command: maintenance
cmd_maintenance() {
    require_root

    log "Running maintenance tasks..."

    # Update system packages
    log "Updating system packages..."
    apt-get update
    DEBIAN_FRONTEND=noninteractive apt-get upgrade -y

    # Clean up old packages
    log "Cleaning up old packages..."
    apt-get autoremove --purge -y
    apt-get clean

    # Clean old journal logs
    log "Cleaning old journal logs..."
    journalctl --vacuum-time=7d

    # Update application
    if [[ -d "$APP_DIR/.git" ]]; then
        log "Updating application..."
        cd "$APP_DIR"

        # Check if there are updates
        git fetch
        if ! git diff --quiet HEAD origin/main; then
            # Notify users before updating
            cmd_notify "System Maintenance" "System is applying updates" "critical"

            git pull
            npm ci
            npm run build
            systemctl restart kioskbook-app.service

            # Dismiss notification
            if [[ "$USER" == "kiosk" ]]; then
                DISPLAY=:0 dunstctl close-all
            else
                DISPLAY=:0 sudo -u kiosk dunstctl close-all
            fi

            log_success "Application updated and restarted"
        fi
    fi

    # Check if reboot is required
    if [[ -f /var/run/reboot-required ]]; then
        log_warning "System reboot required for updates to take effect"

        # Send notification to display
        cmd_notify "System Maintenance" "System will reboot in 30 seconds for updates" "critical"
        sleep 30

        log "Rebooting system..."
        reboot
    fi

    log_success "Maintenance complete"
}

# Command: monitor
cmd_monitor() {
    if [[ -x /usr/local/bin/kioskbook-monitor ]]; then
        /usr/local/bin/kioskbook-monitor
    else
        log_warning "Monitoring script not installed"
    fi
}

# Command: notify
cmd_notify() {
    local title="${1:-Notification}"
    local message="${2:-}"
    local urgency="${3:-normal}"

    if [[ -z "$message" ]]; then
        log_error "Usage: kiosk notify <title> <message> [urgency]\n  urgency: low, normal, critical (default: normal)"
    fi

    # Send notification to the kiosk display
    if [[ "$USER" == "kiosk" ]]; then
        # Already running as kiosk user
        DISPLAY=:0 notify-send \
            -u "$urgency" \
            -a "KioskBook" \
            "$title" \
            "$message"
    else
        # Running as another user (e.g., root)
        DISPLAY=:0 sudo -u kiosk notify-send \
            -u "$urgency" \
            -a "KioskBook" \
            "$title" \
            "$message"
    fi
}

# Show help
cmd_help() {
    echo -e "${CYAN}KioskBook Management CLI${NC}"
    echo ""
    echo -e "${YELLOW}Usage:${NC}"
    echo "  kiosk <command> [options]"
    echo ""
    echo -e "${YELLOW}Commands:${NC}"
    echo -e "  ${GREEN}version${NC}              Show installed version"
    echo -e "  ${GREEN}status${NC}               Show system status"
    echo -e "  ${GREEN}health${NC} [--detailed] Run health check"
    echo -e "  ${GREEN}logs${NC} [-f] [-n NUM]  View application logs"
    echo -e "  ${GREEN}modules${NC}              List available modules"
    echo -e "  ${GREEN}update${NC} <module|all> Update specific module or all"
    echo -e "  ${GREEN}restart${NC} [service]    Restart services (app|display|all)"
    echo -e "  ${GREEN}maintenance${NC}          Run maintenance tasks"
    echo -e "  ${GREEN}monitor${NC}              Run monitoring check"
    echo -e "  ${GREEN}notify${NC} <title> <msg> Send notification to display"
    echo -e "  ${GREEN}help${NC}                 Show this help message"
    echo ""
    echo -e "${YELLOW}Examples:${NC}"
    echo "  kiosk status"
    echo "  kiosk health --detailed"
    echo "  kiosk logs -f"
    echo "  kiosk update 30-display"
    echo "  kiosk update all"
    echo "  kiosk restart app"
    echo "  kiosk maintenance"
    echo ""
    echo -e "${YELLOW}Version Management:${NC}"
    echo -e "  Use ${GREEN}kiosk version${NC} to check for updates"
    echo -e "  Use ${GREEN}kiosk update all${NC} to update to latest version"
    echo ""
}

# Main command dispatcher
main() {
    local command="${1:-help}"

    case "$command" in
        version|v)
            cmd_version
            ;;
        status|s)
            cmd_status
            ;;
        health|h)
            shift
            cmd_health "$@"
            ;;
        logs|l)
            shift
            cmd_logs "$@"
            ;;
        modules|m)
            cmd_modules
            ;;
        update|u)
            shift
            cmd_update "$@"
            ;;
        restart|r)
            shift
            cmd_restart "$@"
            ;;
        maintenance)
            cmd_maintenance
            ;;
        monitor)
            cmd_monitor
            ;;
        notify|n)
            shift
            cmd_notify "$@"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            log_error "Unknown command: $command\nRun 'kiosk help' for usage information."
            ;;
    esac
}

# Run main
main "$@"
